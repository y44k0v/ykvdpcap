{
    "collab_server" : "",
    "contents" : "#' Read file\n#'\n#' This is a function which reads the NOAA earthquake data from a file\n#' into a dataframe and converts it into a tbl_df object\n#'\n#' @param filename A character string which is the name of the file\n#'    with the NOAA earthquake date\n#'\n#' @return This function returns the earthquake data in a tbl_df object\n#'\n#' @note If the filename does not exist, the function stops with an\n#'    error message.\n#'\n#' @importFrom readr read_delim\n#' @importFrom dplyr tbl_df\n#'\n#' @examples\n#' \\dontrun{\n#' filename<-system.file(\"extdata\",\"data.gz\",package=\"ykvdpcap\")\n#' eq_data_read(filename)\n#' }\n#'\n#' @export\neq_data_read <- function(filename) {\n\n        if(!file.exists(filename))\n                stop(\"file '\", filename, \"' does not exist\")\n        data <- suppressMessages({\n                readr::read_delim(filename, delim='\\t',progress = FALSE)\n        })\n        dplyr::tbl_df(data)\n\n}\n\n\n#' Cleans NOAA earthquake data\n#'\n#' This is a function which generates a DATE column and changes LATITUDE, LONGITUDE,\n#' EQ_PRIMARY, and DEATHS to numeric variables.  The function calls eq_location_clean\n#' to clean the LOCATION_NAME column into a format suitable for display purposes.\n#'\n#' @param raw_df The raw dataframe created from data in the NOAA file.\n#'\n#' @return This function returns the clean earthquake data in a tbl_df object.\n#'\n#' @importFrom dplyr filter_ mutate_ \"%>%\"\n#' @importFrom tidyr replace_na unite_\n#' @importFrom lubridate as_date\n#'\n#' @examples\n#' \\dontrun{\n#' filename<-system.file(\"extdata\",\"data.gz\",package=\"ykvdpcap\")\n#' readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data()\n#' }\n#'\n#' @export\neq_clean_data <- function(raw_df) {\n\n        #test that correct columns are present\n        all_columns <- colnames(raw_df)\n\n        stopifnot(any('YEAR' %in% all_columns),any('MONTH' %in% all_columns),\n                  any('DAY' %in% all_columns),any('LATITUDE' %in% all_columns),\n                  any('LONGITUDE' %in% all_columns),any('EQ_PRIMARY' %in% all_columns),\n                  any('DEATHS' %in% all_columns),any('LOCATION_NAME' %in% all_columns))\n\n        #date cleanup\n        #dates which were BC will be removed as date functions don't support these dates\n        #earliest year is now 10 AD\n\n        tryCatch({\n                eq_clean1<-raw_df %>% tidyr::replace_na(list(MONTH = 1,DAY = 1))%>%\n                        dplyr::filter_(~ YEAR > 0) %>%\n                        tidyr::unite_('DATE',c('YEAR','MONTH','DAY'),sep = '-') %>%\n                        dplyr::mutate_(DATE = ~ lubridate::as_date(DATE))\n        }, error = function(e) {\n                stop(\"YEAR,MONTH,DAY not converted to DATE\")\n                return(NULL)\n        })\n\n\n        #change LATITUDE, LONGITUDE, EQ_PRIMARY, DEATHS to numeric\n        eq_clean2<-eq_clean1 %>% dplyr::mutate_(LATITUDE = ~ as.numeric(LATITUDE),LONGITUDE = ~ as.numeric(LONGITUDE),\n                                                EQ_PRIMARY = ~ as.numeric(EQ_PRIMARY),DEATHS = ~ as.numeric(DEATHS))\n\n        #call eq_location_clean function to clean up location\n        eq_clean<-eq_location_clean(eq_clean2)\n\n        return(eq_clean)\n\n}\n\n\n#' Cleans the LOCATION_NAME column in NOAA earthquake data\n#'\n#' This function cleans the LOCATION_NAME column by removing\n#' the COUNTRY at the beginning of the string.  The function\n#' also converts the location names to title case for display\n#' purposes.\n#'\n#' @details This function is called from the eq_clean_data function.\n#'\n#' @param eq_cleanup The dataframe with the NOAA data that has some\n#'    modified columns.\n#'\n#' @return This function returns the earthquake data with a cleaned\n#'    LOCATION_NAME column in a tbl_df object.\n#'\n#' @importFrom dplyr mutate_ \"%>%\"\n#' @importFrom tidyr replace_na\n#' @importFrom stringr str_detect str_match str_to_title\n#'\n#' @examples\n#' \\dontrun{\n#' Recommended:\n#' filename<-system.file(\"extdata\",\"data.gz\",package=\"ykvdpcap\")\n#' readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data()\n#'\n#' To clean just the LOCATION_NAME column:\n#' filename<-system.file(\"extdata\",\"data.gz\",package=\"ykvdpcap\")\n#' readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_location_clean()\n#' }\n#'\n#' @export\neq_location_clean <- function(eq_cleanup) {\n\n        #test that LOCATION_NAME column is present\n        all_columns <- colnames(eq_cleanup)\n        stopifnot(any('LOCATION_NAME' %in% all_columns))\n\n        #handle outlier cases so they work with regex\n        #one LOCATION_NAME is NA, replace with COUNTRY\n        eq_cleanloc1 <- eq_cleanup %>% dplyr::mutate_(LOCATION_NAME = ~ ifelse(is.na(LOCATION_NAME),COUNTRY,LOCATION_NAME))\n\n        #if LOCATION_NAME=COUNTRY, add COUNTRY to LOCATION_NAME so LOCATION_NAME is retained\n        eq_cleanloc2 <- eq_cleanloc1 %>%\n                dplyr::mutate_(LOCATION_NAME = ~ ifelse(LOCATION_NAME==COUNTRY, paste0(COUNTRY,\":  \",LOCATION_NAME),LOCATION_NAME))\n\n        #if there is no COUNTRY in LOCATION_NAME field, add KEEP: so that regex won't strip LOCATION_NAME\n        eq_cleanloc3 <- eq_cleanloc2 %>%\n                dplyr::mutate_(LOCATION_NAME = ~ ifelse(!stringr::str_detect(LOCATION_NAME,\":\"), paste0(\"KEEP:  \",LOCATION_NAME),LOCATION_NAME))\n\n        #regex to clean up LOCATION_NAME - removes first COUNTRY name only\n        #regex includes punctuation as some COUNTRY names include punctuation\n        eq_cleanloc4 <- eq_cleanloc3 %>%\n                dplyr::mutate_(LOCATION_NAME = ~ stringr::str_match(LOCATION_NAME,\"^[a-zA-Z\\\\s()-;',\\\\.]+:\\\\s*(.*)\")[,2])\n\n        #check for any blank values\n        #eq_cleanloc5 <- eq_cleanloc4 %>% dplyr::mutate_(LOCATION_NAME = ~ ifelse(LOCATION_NAME==\"\",COUNTRY,LOCATION_NAME))\n\n        #convert LOCATION_NAME to title format\n        eq_cleanloc5 <- eq_cleanloc4 %>% dplyr::mutate_(LOCATION_NAME = ~ stringr::str_to_title(LOCATION_NAME))\n\n\n}\n\n\n#' Creates a timeline visualization for NOAA earthquake data.\n#'\n#' This function generates a timeline visualization for the NOAA\n#' earthquake data.  The data should be subsetted in order to create\n#' an understandable visualization.  There are several ways to call\n#' the function so that different visualizations are generated.  The\n#' function is a wrapper function and calls geom_timeline and if a\n#' label is specified, also calls the geom_timeline_label function.\n#'\n#'\n#'\n#' @param eq_clean  The clean earthquake data in a tbl_df object.\n#'\n#' @param y Optional parameter for COUNTRY; specifes a separate\n#'    timeline for each country.\n#'\n#' @param size Optional parameter for earthquake magnitude (EQ_PRIMARY);\n#'    specifies a point size based on magnitude.\n#'\n#' @param color Optional parameter for number of deaths (DEATHS);\n#'    specifies a point color based on deaths.\n#'\n#' @param alpha Optional parameter for point transparency.\n#'\n#' @param timeline_label Optional parameter to select timeline labeling.\n#'\n#' @param n_max Optional parameter to specify number of earthquakes to\n#'    be labeled.  The earthquakes with n_max highest magnitudes will be\n#'    labeled.\n#'\n#' @return This function returns a timeline visualization for a subset\n#'    of the earthquake data.\n#'\n#' @import ggplot2\n#'\n#' @examples\n#' \\dontrun{\n#'\n#' filename<-system.file(\"extdata\",\"data.gz\",package=\"ykvdpcap\")\n#'\n#' readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data() %>%\n#' dplyr::filter(COUNTRY == \"USA\" & lubridate::year(DATE) >= 2000) %>%\n#' eq_time(size=\"EQ_PRIMARY\",color=\"DEATHS\")\n#'\n#' readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data() %>%\n#' dplyr::filter(COUNTRY == \"USA\" & lubridate::year(DATE) >= 2000) %>%\n#' eq_time(size=\"EQ_PRIMARY\",color=\"DEATHS\",alpha=0.5,timeline_label=TRUE,n_max=8)\n#'\n#' readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data() %>%\n#' dplyr::filter((COUNTRY==\"USA\" | COUNTRY==\"CHINA\") & lubridate::year(DATE) >= 2000) %>%\n#' eq_time(y=\"COUNTRY\",color=\"DEATHS\",alpha=0.5)\n#'\n#' readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data() %>%\n#' dplyr::filter((COUNTRY==\"USA\" | COUNTRY==\"CHINA\") & lubridate::year(DATE) >= 2000) %>%\n#' eq_time(y=\"COUNTRY\",color=\"DEATHS\",alpha=0.5,timeline_label=TRUE)\n#'\n#' }\n#' @export\neq_time <- function(eq_clean=NULL,y=NULL,size=NULL,color=NULL,alpha=0.4,timeline_label=FALSE,n_max=5){\n\n        #check to see if invalid input values provided\n\n        #test that DATE column is present\n        all_columns <- colnames(eq_clean)\n        stopifnot(any('DATE' %in% all_columns))\n\n        if(! is.null(y)) {\n                if(y !=\"COUNTRY\") {\n                        stop(\"Invalid column for y - use COUNTRY\")\n                }\n        }\n\n        if(!is.null(size)) {\n                if(size != \"EQ_PRIMARY\") {\n                        stop(\"Invalid column for size - use EQ_PRIMARY\")\n                }\n        }\n\n        if(!is.null(color)) {\n                if(color != \"DEATHS\") {\n                        stop(\"Invalid column for color - use DEATHS\")\n                }\n        }\n\n        if(!is.logical(timeline_label)) {\n                warning(\"Invalid column for timeline_label - set to FALSE\")\n                timeline_label=FALSE\n        }\n\n        if(!is.null(alpha)) {\n                if(is.numeric(alpha)){\n                        if(alpha <0  | alpha > 1) {\n                                warning(\"Invalid value for alpha - set alpha to 0.4\")\n                                alpha = 0.4\n                        }\n                }else{\n                        warning(\"Invalid value for alpha - set alpha to 0.4\")\n                        alpha = 0.4\n                }\n        }\n\n        if(!is.null(n_max)) {\n                if(is.numeric(n_max)) {\n                        if(!(n_max %% 1 == 0) | (n_max < 0)){\n                                warning(\"Invalid value for n_max - set n_max to 5\")\n                                n_max = 5\n                        }\n                }else{\n                        warning(\"Invalid value for n_max - set n_max to 5\")\n                        n_max = 5\n                }\n        }\n\n        if(is.null(y)) {\n\n                country<-unique(eq_clean$COUNTRY)\n                timeline<- ggplot() +\n                        geom_timeline(data=eq_clean,aes_string(x=\"DATE\",size=size,color=color),alpha=alpha) +\n                        theme_classic() +\n                        theme(legend.position=\"bottom\",axis.line.y=element_blank(),\n                              axis.line.x=element_line(color=\"black\", size = 1),\n                              plot.caption = element_text(hjust=0.5, size=rel(1.2)),\n                              plot.margin = unit(c(0.5, 1, 1, 1), \"lines\")) +\n                        labs(caption=paste0(\"Earthquake Timeline for \",country)) +\n                        scale_color_continuous(name=\"# Deaths\") +\n                        scale_size_continuous(name=\"Richter Scale value\") +\n                        scale_alpha_continuous(guide=FALSE)\n\n        }else {\n\n                country<-unique(eq_clean$COUNTRY)\n                country_string<-paste(country,collapse=' & ')\n                timeline<- ggplot() +\n                        geom_timeline(data=eq_clean,aes_string(x=\"DATE\",y=y,size=size,color=color),alpha=alpha) +\n                        theme_classic() +\n                        theme(legend.position=\"bottom\",axis.line.y=element_blank(),\n                              axis.line.x=element_line(color=\"black\", size = 1),\n                              plot.caption = element_text(hjust=0.5, size=rel(1.2)),\n                              plot.margin = unit(c(0.5, 1, 1, 1), \"lines\"),\n                              axis.title.y=element_blank(),\n                              axis.ticks.y = element_blank()) +\n                        labs(caption=paste0(\"Earthquake Timeline for \",country_string)) +\n                        scale_color_continuous(name=\"# Deaths\") +\n                        guides(color = guide_legend(label.position=\"bottom\",\n                                                    label.hjust = 0.5, label.vjust = 0.5,\n                                                    label.theme = element_text(angle = 45))) +\n                        scale_size_continuous(name=\"Richter Scale value\") +\n                        scale_alpha_continuous(guide =FALSE )\n        }\n\n\n\n        #get timeline_label\n        if(isTRUE(timeline_label)) {\n\n                if(is.null(y)) {\n                        timeline_label<-geom_timeline_label(data=eq_clean,aes_string(x=\"DATE\",label=\"LOCATION_NAME\"),n_max=n_max)\n                }else{\n                        timeline_label<-geom_timeline_label(data=eq_clean,aes_string(x=\"DATE\",y=y,label=\"LOCATION_NAME\"),n_max=n_max)\n                }\n\n                print(timeline + timeline_label)\n\n        }else{\n\n                print(timeline)\n\n        }\n\n}\n\n\n#' Create a timeline geom\n#'\n#' This function adds a geom which displays a timeline for\n#' NOAA earthquake data.  This is the basic timeline visualization\n#' without additional modifications.  For a cleaner visualization\n#' the wrapper function, eq_time, should be used.\n#'\n#' @param mapping A set of aesthetic mappings.  If null, uses the\n#'   default setting in ggplot()\n#' @param data A dataset If null, uses the default data specified\n#'   in ggplot()\n#' @param stat The name of the statistical transformation to use.\n#'   Identity means keep the data as is.\n#' @param position The method used to adjust overlapping objects.\n#'   Identity means keep the position as is.\n#' @param na.rm Flag to remove values with NA\n#' @param show.legend Flag to say whether layer should be present in legend.\n#' @param inherit.aes Flag to say whether default aesthetics should be inherited.\n#' @param ... Additional arguments passed to layer()\n#'\n#' @note The parameters for GeomTimeLine include columns from the earthquake data:\n#'   Required parameters: x=DATE\n#'   Optional parameters: y=COUNTRY,size=EQ_PRIMARY,color=DEATHS,alpha=x where x\n#'   is a number from 0 to 1\n#'\n#'\n#' @return This function returns a layer that can be added to a plot\n#'   using the ggplot function\n#'\n#' @examples\n#' \\dontrun{\n#' readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data() %>%\n#' dplyr::filter(COUNTRY == \"USA\" & lubridate::year(DATE) >= 2000) %>%\n#' ggplot() +\n#' geom_timeline(aes(x=DATE,size=EQ_PRIMARY,color=DEATHS),alpha=0.5)\n#'\n#' readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data() %>%\n#' dplyr::filter((COUNTRY==\"USA\" | COUNTRY==\"CHINA\") & lubridate::year(DATE) >= 2000) %>%\n#' ggplot() +\n#' geom_timeline(aes(x=DATE,y=COUNTRY,size=EQ_PRIMARY,color=DEATHS),alpha=0.5)\n#'\n#' }\n#'\n#'@export\ngeom_timeline <- function(mapping = NULL, data = NULL, stat = \"identity\",\n                          position = \"identity\", na.rm = FALSE,\n                          show.legend = NA, inherit.aes = TRUE, ...) {\n\n\n        ggplot2::layer(\n                geom = GeomTimeLine, mapping = mapping,\n                data = data, stat = stat, position = position,\n                show.legend = show.legend, inherit.aes = inherit.aes,\n                params = list(na.rm = na.rm, ...)\n        )\n\n\n}\n\n# Geom definition for GeomTimeLine\nGeomTimeLine <- ggproto(\"GeomTimeLine\", Geom,\n                        required_aes = c(\"x\"),\n                        non_missing_aes = c(\"size\", \"shape\", \"colour\"),\n                        default_aes = aes(y = 0.05,\n                                          shape = 19, colour = \"gray\", alpha=0.4,\n                                          size = 4, stroke = 0.5, fill=NA\n                        ),\n                        draw_key = draw_key_point,\n                        draw_group = function(data, panel_scales, coord) {\n\n                                ## Transform the data\n                                coords <- coord$transform(data,panel_scales)\n\n                                ## Construct a grid grob\n                                grid::pointsGrob(\n                                        coords$x,\n                                        coords$y,\n                                        pch=coords$shape,\n                                        gp = grid::gpar(\n                                                size = coords$size,\n                                                col = alpha(coords$colour, coords$alpha),\n                                                fill = alpha(coords$fill, coords$alpha),\n                                                # Stroke is added around the outside of the point\n                                                fontsize = coords$size * .pt + coords$stroke * .stroke / 2,\n                                                lwd = coords$stroke * .stroke / 2\n                                        )\n\n                                )\n                        }\n)\n\n#' Create a timeline label geom\n#'\n#' This function adds a geom which displays labels for points on\n#' a timeline for NOAA earthquake data.  This is the basic label\n#' visualization without additional modifications.  For a cleaner\n#' visualization the wrapper function, eq_time, should be used.\n#'\n#' @param mapping A set of aesthetic mappings.  If null, uses the\n#'   default setting in ggplot()\n#' @param data A dataset If null, uses the default data specified\n#'   in ggplot()\n#' @param stat The name of the statistical transformation to use.\n#'   Identity means keep the data as is.\n#' @param position The method used to adjust overlapping objects.\n#'   Identity means keep the position as is.\n#' @param na.rm Flag to remove values with NA\n#' @param show.legend Flag to say whether layer should be present in legend.\n#' @param inherit.aes Flag to say whether default aesthetics should be inherited.\n#' @param ... Additional arguments passed to layer()\n#' @param n_max The number of earthquakes to be labeled.  The earthquakes\n#'   with n_max highest magnitudes will be labeled.\n#'\n#'\n#' @note The parameters for GeomTimeLineLabel include columns from the earthquake data:\n#'   Required parameters: x=DATE, label=LOCATION_NAME\n#'   Optional parameters: n_max=x where x\n#'   is the number of earthquakes with the highest\n#'   magnitude to label.\n#'\n#'\n#' @return This function returns a layer that can be added to a plot\n#'   using the ggplot function\n#'\n#' @importFrom dplyr group_by_ filter_ min_rank \"%>%\"\n#'\n#'\n#' @examples\n#' \\dontrun{\n#' sample_USA <- readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data() %>%\n#' dplyr::filter(COUNTRY == \"USA\" & lubridate::year(DATE) >= 2000)\n#'\n#' ggplot(data = sample_USA, aes(x=DATE)) + geom_timeline() +\n#' geom_timeline_label(data=sample_USA,aes(label=LOCATION_NAME),n_max=8) + theme_classic()\n#'\n#' ggplot() +\n#' geom_timeline_label(data=sample_USA,aes(x=DATE,label=LOCATION_NAME))\n#'\n#' sample_2_countries<- readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data() %>%\n#' dplyr::filter((COUNTRY==\"USA\" | COUNTRY==\"CHINA\") & lubridate::year(DATE) >= 2000)\n#'\n#' ggplot() +\n#' geom_timeline_label(data=sample_2_countries,aes(x=DATE,y=COUNTRY,label=LOCATION_NAME))\n#' }\n#'\n#' @export\ngeom_timeline_label <- function(mapping = NULL, data = NULL, stat = \"identity\",\n                                position = \"identity\", na.rm = FALSE,\n                                show.legend = NA, inherit.aes = TRUE, n_max = 5, ...) {\n\n\n        #top n_max using NSE\n        data2 <- data %>% dplyr::group_by_(~ COUNTRY) %>%\n                dplyr::filter_(~ min_rank(desc(EQ_PRIMARY)) <= n_max)\n\n        #equivalent to top_n call:\n        #data2 <- data %>% dplyr::group_by_(~ COUNTRY) %>% dplyr::top_n(n_max,EQ_PRIMARY)\n\n        ggplot2::layer(\n                geom = GeomTimeLineLabel, mapping = mapping,\n                data = data2, stat = stat, position = position,\n                show.legend = show.legend, inherit.aes = inherit.aes,\n                params = list(na.rm = na.rm, ...)\n        )\n\n}\n\n\n\n\n# Geom definition for GeomTimeLineLabel\nGeomTimeLineLabel <- ggproto(\"GeomTimeLineLabel\", Geom,\n                             required_aes = c(\"x\",\"label\"),\n                             default_aes = aes(y=0.1, colour = \"black\", size = 0.2,\n                                               linetype = 1, alpha = NA, angle = 45,\n                                               hjust = 0, vjust = 0,\n                                               family = \"\", fontface = 2, lineheight = 1.5),\n                             draw_key = draw_key_label,\n                             draw_group = function(data,panel_scales,coord) {\n\n\n                                     ## Transform the data\n                                     coords <- coord$transform(data,panel_scales)\n\n                                     #create grid grob\n                                     # 2 parts - vertical line and text label\n\n                                     vline <- grid::segmentsGrob(\n                                             x0 = coords$x, x1 = coords$x,\n                                             y0 = coords$y, y1 = coords$y + 0.1,\n                                             default.units = \"native\",\n                                             gp = grid::gpar(\n                                                     size=0.5,\n                                                     alpha=1,\n                                                     color=\"black\")\n                                     )\n\n                                     line_annot <- grid::textGrob(\n                                             coords$label,\n                                             x=coords$x,\n                                             y=coords$y + 0.1,\n                                             default.units = \"native\",\n                                             hjust = coords$hjust, vjust = coords$vjust,\n                                             rot = coords$angle,\n                                             gp = grid::gpar(\n                                                     col = \"black\",\n                                                     alpha=1,\n                                                     fontsize = 3.5 * .pt,\n                                                     fontfamily = coords$family,\n                                                     fontface = coords$fontface,\n                                                     lineheight = coords$lineheight\n                                             )\n                                     )\n                                     timeline_label <- grid::gTree(children = grid::gList(vline,line_annot))\n                             }\n\n)\n\n#' Creates interactive map visualization of NOAA earthquake data.\n#'\n#'\n#' This function generates a map visualization for the NOAA earthquake\n#' data.  The data should be subsetted in order to create an understandable\n#' visualization.  The earthquakes are mapped based on the latitude and\n#' longitude of the earthquake epicenter.  The function is a wrapper function\n#' and calls the leaflet function to generate the map.  The epicenter is\n#' annotated based on an annot_col which the user can specify.  In addition,\n#' if the user specifies \"popup_text\" then a call to eq_create_label generates\n#' the appropriate text for the popup.\n#'\n#' @references \\url{http://rstudio.github.io/leaflet/}\n#'\n#' @param eq_clean The clean earthquake data in a tbl_df object.\n#' @param annot_col Column in the tbl_df object to be used for annotation.\n#'\n#' @return This function returns an interactive map.\n#'\n#' @note If an invalid column name is provided, the function provides a warning\n#' and uses the LOCATION_NAME column as teh annotation column.\n#'\n#' @import leaflet\n#'\n#' @examples\n#' \\dontrun{\n#'\n#' filename<-system.file(\"extdata\",\"data.gz\",package=\"ykvdpcap\")\n#' readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data() %>%\n#' dplyr::filter(COUNTRY == \"MEXICO\" & lubridate::year(DATE) >= 2000) %>%\n#' eq_map(annot_col = \"DATE\")\n#'\n#'\n#' filename<-system.file(\"extdata\",\"data.gz\",package=\"ykvdpcap\")\n#' readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data() %>%\n#' dplyr::filter(COUNTRY == \"MEXICO\" & lubridate::year(DATE) >= 2000) %>%\n#' dplyr::mutate(popup_text = eq_create_label(.)) %>%\n#' eq_map(annot_col = \"popup_text\")\n#'\n#' }\n#'\n#' @export\neq_map <- function(eq_clean=NULL, annot_col=\"DATE\"){\n\n        #test that correct columns are present\n        all_columns <- colnames(eq_clean)\n\n        stopifnot(any('DATE' %in% all_columns),any('LATITUDE' %in% all_columns),\n                  any('LONGITUDE' %in% all_columns),any('EQ_PRIMARY' %in% all_columns))\n\n        #check to see if invalid column provided - print message and default to DATE\n        if(!(any(annot_col %in% all_columns))) {\n                warning(\"Invalid Column - DATE Displayed\")\n                annot_col = \"DATE\"\n        }\n\n        #call to leaflet\n        leaflet::leaflet() %>%\n                leaflet::addTiles() %>%\n                leaflet::addCircleMarkers(data = eq_clean, lng = ~ LONGITUDE, lat = ~ LATITUDE, radius = ~ EQ_PRIMARY,\n                                          weight=1, fillOpacity = 0.2, popup =~ paste(get(annot_col)))\n\n}\n\n#' Creates popup text for markers.\n#'\n#' This function generates HTML formatted text to be used in\n#' popups for map markers.\n#'\n#' @param eq_clean The clean earthquake data in a tbl_df object.\n#'\n#' @return This function returns a character vector containing\n#'    popup text to be used in a leaflet visualization.\n#'\n#'\n#' @importFrom dplyr mutate_ select_ collect \"%>%\"\n#' @importFrom tidyr unite_\n#'\n#'\n#' @examples\n#' \\dontrun{\n#' filename<-system.file(\"extdata\",\"data.gz\",package=\"ykvdpcap\")\n#'\n#' data_with_popup<-readr::read_delim(filename, delim = \"\\t\") %>%\n#' eq_clean_data() %>%\n#' dplyr::filter(COUNTRY == \"MEXICO\" & lubridate::year(DATE) >= 2000) %>%\n#' dplyr::mutate(popup_text = eq_create_label(.))\n#'\n#'\n#' }\n#'\n#' @export\neq_create_label <- function(eq_clean=NULL) {\n\n        #test that correct columns are present\n        all_columns <- colnames(eq_clean)\n\n        stopifnot(any('LOCATION_NAME' %in% all_columns),any('EQ_PRIMARY' %in% all_columns),\n                  any('DEATHS' %in% all_columns))\n\n        #use dplyr to create values for \"popup_text\" column\n        #remove labels for values with NA\n        #check for empty string - return \"All Values are NA\"\n        data2<- eq_clean %>% dplyr::select_(.dots=c('LOCATION_NAME','EQ_PRIMARY','DEATHS')) %>%\n                dplyr::mutate_(new_LOCATION_NAME = ~ ifelse(is.na(LOCATION_NAME), LOCATION_NAME, paste0(\"<b>Location:</b> \", LOCATION_NAME,\"<br />\"))) %>%\n                dplyr::mutate_(new_EQ_PRIMARY = ~ ifelse(is.na(EQ_PRIMARY), EQ_PRIMARY, paste0(\"<b>Magnitude:</b> \", EQ_PRIMARY,\"<br />\"))) %>%\n                dplyr::mutate_(new_DEATHS = ~ ifelse(is.na(DEATHS), DEATHS, paste0(\"<b>Total Deaths:</b> \", DEATHS))) %>%\n                tidyr::unite_('popup_values',c('new_LOCATION_NAME','new_EQ_PRIMARY','new_DEATHS'),sep ='') %>%\n                dplyr::mutate_(popup_values = ~ stringr::str_replace_all(popup_values,\"[,]*NA[,]*\",\"\")) %>%\n                dplyr::mutate_(popup_values = ~ ifelse(popup_values==\"\",\"All Values are NA\",popup_values))\n\n        popup_values <- dplyr::collect(dplyr::select_(data2,.dots=c('popup_values')))[[1]]\n\n        return(popup_values)\n\n}\n\n",
    "created" : 1500534259761.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3342182543",
    "id" : "E555E673",
    "lastKnownWriteTime" : 1500570501,
    "last_content_update" : 1500570501256,
    "path" : "C:/Users/win10/Desktop/Coursera/Rpackages/ykvdpcap/R/earthquake_functions.R",
    "project_path" : "R/earthquake_functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}